#lang racket

(require (only-in "utils.rkt"
                  symbol-append datum?))

(provide closure-convert)

; Input Language
;
; e  ::= (let ([x (apply-prim op ae)]) e)
;      | (let ([x (prim op ae ...)]) e)
;      | (let ([x (lambda (x ...) e)]) e)
;      | (let ([x (lambda x e)]) e)
;      | (let ([x (quote dat)]) e)
;      | (apply ae ae)
;      | (ae ae ...)
;      | (if ae e e)
;
; ae ::= (lambda (x ...) e)
;      | (lambda x e)
;      | x
;      | (quote dat)
;
; Output Language
;
; p ::= ((proc (x x ...) e) ...)
; e ::= (let ([x (apply-prim op x)]) e)
;     | (let ([x (prim op x ...)]) e)
;     | (let ([x (make-closure x x ...)]) e)
;     | (let ([x (env-ref x nat)]) e)
;     | (let ([x (quote dat)]) e)
;     | (clo-app x x ...)
;     | (if x e e)


; This file does closure conversion.
; We turn syntactic lambdas into closures, which pair them with an environment.
; This pass outputs a grammar that is a list of procedures.
; Each proc in this list can be directly translated to LLVM IR.

; removes lambdas and datums from ae and forces them to be let bound.
; symbols are the only ae left after this
; TODO: test this? do it lazy davis
(define (remove-ae-forms ce)
  ; takes a function to call after all aes have been processed
  ; when encountering a non-symbol ae, will expand it to a let form,
  ; and then continue. After all have been processed, fin is used
  ; to let the caller determine the final expression in the chain of lets.
  (define (expand-aes fin todo done)
    (match todo
      ; we accumulate done backwards, so reverse it at the end.
      ['() (fin (reverse done))]
      [`(,hae ,tae ...)
       (define aearg (gensym 'ae))
       (if (symbol? hae)
           (expand-aes fin tae (cons hae done))
           (remove-ae-forms `(let ([,aearg ,hae]) ,(expand-aes fin tae (cons aearg done)))))]))
  (match ce
    ; apply-prim removal
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (apply-prim ,op ,@done)]) ,(remove-ae-forms letbody)))
                 (list ae) '())]
    ; Prim removal
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (prim ,op ,@done)]) ,(remove-ae-forms letbody))) aes '())]
    ; Lambda removal
    [`(let ([,x (lambda ,xargs ,lambody)]) ,letbody)
     `(let ([,x (lambda ,xargs ,(remove-ae-forms lambody))]) ,(remove-ae-forms letbody))]
    ; Dat removal
    [`(let ([,x ',dat]) ,letbody)
     `(let ([,x ',dat]) ,(remove-ae-forms letbody))]
    ; apply removal
    [`(apply ,aef ,aearglist)
     (expand-aes (λ (done) `(apply ,@done)) (list aef aearglist) '())]
    ; If removal
    [`(if ,aec ,et ,ef)
     (expand-aes (λ (done) `(if ,@done ,(remove-ae-forms et) ,(remove-ae-forms ef))) (list aec) '())]
    ; application removal
    [`(,aef ,aes ...)
     (expand-aes (λ (done) done) (cons aef aes) '())]))

; quick function in effort of making more readable arg-lists.
(define (number->symbol n)
  (string->symbol (number->string n)))

; turn (λ (xs ...) e) -> (λ xs e) -> (λ (xs) e)
; turn (λ xs e) -> (λ (xs) e)
; AKA turn every λ into a 1-arg positional that takes an explicit list
; and change call-sites to make the lists
; This takes the grammar generated by remove-ae-forms,
; so lambdas are guaranteed to be let bound, and the only ae is a symbol.
; a nice side effect is that this pass removes the 'apply' form, as thats what everything becomes!
(define (unify-lambdas ce)
  (match ce
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody)
     `(let ([,x (apply-prim ,op ,ae)]) ,(unify-lambdas letbody))]
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody)
     `(let ([,x (prim ,op ,@aes)]) ,(unify-lambdas letbody))]
    [`(let ([,x (lambda (,xs ...) ,lambody)]) ,letbody)
     (define (listify-lam todo restarg)
       (define nextrestarg (gensym 'arglist))
       (match todo
         ['() (unify-lambdas lambody)]
         ; special case so we dont have a useless binding at the end
         [`(,h)
          `(let ([,h (prim car ,restarg)]) ,(unify-lambdas lambody))]
         [`(,h ,t ...)
          `(let ([,h (prim car ,restarg)])
             (let ([,nextrestarg (prim cdr ,restarg)])
               ,(listify-lam t nextrestarg)))]))
     (define restarg (gensym 'arglist))
     `(let ([,x (lambda (,restarg) ,(listify-lam xs restarg))]) ,(unify-lambdas letbody))]
    [`(let ([,x (lambda ,xvararg ,lambody)]) ,letbody)
     `(let ([,x (lambda (,xvararg) ,(unify-lambdas lambody))]) ,(unify-lambdas letbody))]
    [`(let ([,x ',dat]) ,letbody)
     `(let ([,x ',dat]) ,(unify-lambdas letbody))]
    [`(apply ,aef ,aelist)
     `(,aef ,aelist)]
    [`(if ,aec ,et ,ef)
     `(if ,aec ,(unify-lambdas et) ,(unify-lambdas ef))]
    [`(,aef ,aes ...)
     ; to create a list in CPS, we need to construct
     ; each cons-cell 1-by-1. All the appending is just
     ; to make nice arg-names like 'argsXXXX-fname-N
     ; so we can more easily see how far into the args list we are.
     (define (layout-untagged fname args argsname count)
       (match args
         ['() `(,fname ,(symbol-append argsname count))]
         [`(,h ,t ...)
          `(let ([,(symbol-append argsname (add1 count))
                  (prim cons ,h ,(symbol-append argsname count))])
             ,(layout-untagged aef t argsname (add1 count)))]))
     ; This is the base-name of the arg list, we append the arg number to it.
     ; use $ as a separator to avoid name mangling when converting to LLVM IR.
     (define argsname (symbol-append (gensym 'args) '$ aef '$))
     ; we start with null, and then as we consume args, we add to the list.
     `(let ([,(symbol-append argsname (number->symbol 0)) '()])
        ,(layout-untagged aef (reverse aes) argsname 0))]))

; (f a b c) -> (clo-app f a b c) -> (C-style-app f[0] f a b c)
; call simplify-ae on input to closure convert, then remove vararg callsites/lambdas
; simplify-ae also forced args to `apply` and `apply-prim` be let-bound symbols.
; which makes processing easier here.
(define (closure-convert cps)
  (define scps (remove-ae-forms cps))
  (define no-varargs-cps (unify-lambdas scps))
  ; take an expression and return:
  ;   the expression for the given expressions closure,
  ;   the set of free vars in the expression,
  ;   the list of generated procs.
  (define (bottom-up-convert e)
    (match e
      ; let lambda, which will create a new proc.
      [`(let ([,(? symbol? var) (lambda (,(? symbol? vararg)) ,lambody)]) ,letbody)
       (match-define `(,let-conv ,let-frees ,let-procs) (bottom-up-convert letbody))
       (match-define `(,lam-conv ,lam-frees ,lam-procs) (bottom-up-convert lambody))
       ; convert to list, which is ordered, becuase we need an order in this from now on.
       (define clo-env-vars-set (set-remove lam-frees vararg))
       (define clo-env-vars (set->list clo-env-vars-set))
       (define clo-name (gensym 'clo))
       (define env-name (gensym 'env))
       (define (layout-clo-env todo count)
         (match todo
           ['() lam-conv]
           [`(,h ,t ...) `(let ([,h (env-ref ,env-name ,count)]) ,(layout-clo-env t (add1 count)))]))
       (define new-proc `(proc (,clo-name ,env-name ,vararg) ,(layout-clo-env clo-env-vars 0)))
       `((let ([,var (make-closure ,clo-name ,@clo-env-vars)]) ,let-conv)
         ,(set-remove (set-union clo-env-vars-set let-frees) var)
         (,new-proc ,@let-procs ,@lam-procs))]
      ; let apply-prim
      [`(let ([,(? symbol? var) (apply-prim ,(? symbol? op) ,(? symbol? arg))]) ,letbody)
       (match-define `(,conv ,frees ,procs) (bottom-up-convert letbody))
       `((let ([,var (apply-prim ,op ,arg)]) ,conv)
         ,(set-add (set-remove frees var) arg)
         ,procs)]
      ; let prim
      [`(let ([,(? symbol? var) (prim ,(? symbol? op) ,(? symbol? args) ...)]) ,letbody)
       (match-define `(,conv ,frees ,procs) (bottom-up-convert letbody))
       `((let ([,var (prim ,op ,@args)]) ,conv)
         ,(foldl (λ (x s) (set-add s x)) (set-remove frees var) args)
         ,procs)]
      ; let quote
      [`(let ([,(? symbol? var) ',(? datum? dat)]) ,letbody)
       (match-define `(,conv ,frees ,procs) (bottom-up-convert letbody))
       `((let ([,var ',dat]) ,conv)
         ,(set-remove frees var)
         ,procs)]
      ; if expression
      [`(if ,(? symbol? xc) ,et ,ef)
       (match-define `(,et-conv ,et-free ,et-procs) (bottom-up-convert et))
       (match-define `(,ef-conv ,ef-free ,ef-procs) (bottom-up-convert ef))
       `((if ,xc ,et-conv ,ef-conv)
         ,(set-union et-free ef-free)
         ,(append et-procs ef-procs))]
      ; closure application
      [`(,(? symbol? f) ,(? symbol? arglist))
       `((clo-app ,f ,arglist) ,(set f arglist) ,(list))]))
  (match-define `(,main-body ,free ,procs) (bottom-up-convert no-varargs-cps))
  (when (not (set-empty? free)) (displayln `(TOPLEVEL-FREE-VARS: ,free)))
  `((proc (main ,(gensym 'mainenv) ,(gensym 'mainargs)) ,main-body) ,@procs))
